<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<title>CS124: Java, Section 6.2</title>
</head>

<body alink="#CC2222" bgcolor="#FFFFFF" link="#0000CC" text="#000000" vlink="#553377">
<blockquote>
<h3>Section 6.2<br>
    Mouse and Keyboard Events and Listeners</h3>

<hr align="center" width="33%">



<p><font size="+2">L</font>IKE MOST EVERYTHING IN JAVA, EVENTS are represented
by objects.  There are several types of events, and each type is represented
by a class.  All the event classes used in the AWT are subclasses
of an abstract class named <tt>java.awt.AWTEvent</tt>.  Event classes
that represent particular types of events, such as <tt>MouseEvent</tt>
and <tt>ActionEvent</tt>, are found in the package <tt>java.awt.event</tt>.
</p>

<p>For an event to have any effect, a program must detect the event
and react to it.  For each event class, there is an <tt>interface</tt>
that defines one or more methods for reacting to events of that class.
For example, associated with the class <tt>ActionEvent</tt> is an
<tt>interface</tt> named <tt>ActionListener</tt>.  This interface
defines a method, "<tt>public void actionPerfromed(ActionEvent evt)</tt>".
An object that wants to respond to action events must implement this
<tt>interface</tt>.  For example, if an applet named <tt>MyApplet</tt>
is to respond to action events, then the definition of the applet
class has the form:</p>

<pre>       public class MyApplet extends Applet <font color="#000099">implements ActionListener</font> {
       
          . . .   // other variables, methods, etc.
          
          <font color="#000099">public void actionPerformed(ActionEvent evt) {
          
             . . . // respond to the action event, evt
             
          }</font>
          
          . . . // other variables, methods, etc.
          
       }
</pre>

<p>By implementing the <tt>ActionListener</tt> interface, an object becomes
<b>capable</b> of "listening" for action events.  But before it can
actually "hear" any events, it must be registered as an action listener.
Events are generated by components.  When the user clicks on
a button, for example, an action event is generated.  Each component that
can generate action events has a method called <tt>addActionListener</tt>.
This method is used to register action listeners with the component.
When the component generates an action event, it notifies any registered action
listeners by calling their <tt>actionPerformed()</tt> methods.  (There can be
more that one listener, but it would be somewhat unusual.)</p>

<p>For example, if <tt>MyApplet</tt> creates a button, <tt>commandButton</tt>, and
wants to be notified when the user clicks on that button, then the applet must
call the method <tt>commandButton.addActionListener(this)</tt>.  The word "<tt>this</tt>"
refers to the applet itself, which means that the notification will be sent to the applet,
by calling the <tt>actionPerfomed()</tt> method of the applet.  The obvious place 
for the applet to create the <tt>commandButton</tt> and set itself up as a listener
would be in its <tt>init()</tt> method, which would look something like this:</p>

<pre>       public void init() {   // initialization method for MyApplet
          . . . // other stuff
          commandButton = new Button("Do It!");
          <font color="#000099">commandButton.addActionListener(this);</font>
          . . . // add commandButton to the applet or to some other container
          . . . // more stuff
       }
</pre>

<p>Of course, <b>any</b> object can play the roll of action listener for the button,
as long as it implements the <tt>ActionListener</tt> interface.
It doesn't have to be the applet that contains the button, and it doesn't even
have to be a GUI component.</p>

<p>When the <tt>actionPerformed()</tt> method is called, a parameter of type
<tt>ActionEvent</tt> is passed to it.  This parameter carries information about
the particular event that has occurred.  Methods for accessing this information
are defined in the <tt>ActionEvent</tt> class.  Each type of event is represented
by a different class because each type of event requires different information to
be sent to listeners.</p>

<p>In this section and the next, I'll discuss the various event classes and their
associated listeners.  The next section covers specialized components like
scroll bars and text-input boxes.  The user interacts with one of these specialized 
components using the mouse or keyboard.  The component detects that
interaction and converts it into a specialized event appropriate to the component.
For example, when the user clicks on a button, the button converts that action into
an <tt>ActionEvent</tt>.  However, there are less specialized, lower level events
associated with the mouse and keyboard, and you can program responses to them.
A button, of course, has already been programmed to respond to mouse events by
sending an <tt>ActionEvent</tt>, and there is generally no need to change
that programming.  However, it is common to program a canvas or an applet to
respond to mouse and keyboard events, and I'll explain how to do that in this
section.</p>


<hr align="center" width="33%">

<h3>Mouse Events</h3>

<p>There are actually two event classes associated with the mouse:  <tt>MouseEvent</tt>
and <tt>MouseMotionEvent</tt>.  There are also two listener interfaces,
<tt>MouseListener</tt> and <tt>MouseMotionListener</tt>.  The <tt>MouseListener</tt>
interface declares the methods</p>

<pre>          public void mousePressed(MouseEvent evt);
          public void mouseReleased(MouseEvent evt);
          public void mouseClicked(MouseEvent evt);
          public void mouseEntered(MouseEvent evt);
          public void mouseExited(MouseEvent evt);
</pre>

<p>and the <tt>MouseMotionListener</tt> declares</p>

<pre>          public void mouseMoved(MouseEvent evt);
          public void mouseDragged(MouseEvent evt);
</pre>

<p>Any component can generate mouse events.  An object that wants to respond to
these events must implement one or both of the listener interfaces.
It must also register itself with the component by calling 
the component's <tt>addMouseListener()</tt> and/or <tt>addMouseMotionListener()</tt>
methods.  Note that an object that implements <tt>MouseListener</tt> must
provide definitions for all five of the methods in that interface, even if a
definition consists just of an empty set of braces.  Similarly, an object
that implements <tt>MouseMotionListener</tt> must define both the
<tt>mouseMoved()</tt> and the <tt>mouseDragged()</tt> methods.</p>

<p>A component calls <tt>mousePressed()</tt> whenever one of the buttons on
the mouse is pressed while the mouse cursor is over that component.  It will then
call the <tt>mouseReleased()</tt> method when the button is released -- even if
the cursor has moved outside of the component by that time.  The <tt>mouseClicked()</tt>
method is called if the button is pressed and released at the same point; it is
called in addition to <tt>mousePressed()</tt> and <tt>mouseReleased()</tt>.
If you simply want to respond to mouse clicks, you should probably do so
in the <tt>mousePressed()</tt> routine, and leave the definitions of 
<tt>mouseReleased()</tt> and <tt>mouseClicked()</tt> empty.  (Use <tt>mouseClicked()</tt>
instead if you want to give the user a chance to change his mind by moving the mouse
cursor before releasing the button.)</p>

<p>The <tt>mouseDragged()</tt> method is called when the user moves the mouse
while holding down one of the buttons on the mouse.  Any number of calls to
<tt>mouseDragged()</tt> can occur between a call to <tt>mousePressed()</tt> and
a call to <tt>mouseReleased()</tt>.  Note that mouse-dragged events come from
the component where the mouse button was originally pressed, even if the mouse
cursor has moved outside that component.</p>

<p>I have rarely found a practical use for <tt>mouseEntered()</tt>, <tt>mouseExited()</tt>,
and <tt>mouseMoved()</tt>.  These have to do with movement of the mouse while no
mouse button is pressed.  They have obvious meanings.  You could, for example, use
<tt>mouseEntered()</tt> and <tt>mouseExited()</tt> to make a component change
its appearance when the mouse cursor is in that component.  In an arcade-style
game, you might use <tt>mouseMoved()</tt> to move a gun around and then use
the <tt>MousePressed()</tt> method to fire the
gun when the user clicks the mouse.</p>

<p>Looking at a simple example might help to make things clearer.  Suppose
you want a canvas that changes color when the user clicks on it.  This could
be done as follows:</p>

<pre>       class ColorChangeCanvas extends Canvas implements MouseListener {
       
          int currentColor = 0;  // 0 for red, 1 for blue, 2 for green
          
          ColorChangeCanvas() { // constructor
             setBackground(Color.red);
             addMouseListener(this);  // Canvas will listen for
                                      //   its own mouse events.
          }
          
          public void mousePressed(MouseEvent evt) {
                // User has clicked on the canvas;
                // cycle its background color and repaint it.
             currentColor++;
             if (currentColor &gt; 2)
                currentColor = 0;
             switch (currentColor) {
                case 0: setBackground(Color.red); break;
                case 1: setBackground(Color.blue); break;
                case 2: setBackground(Color.green); break;
             }
             repaint();
          }
          
          public void mouseReleased(MouseEvent evt) { }   // Definitions required
          public void mouseClicked(MouseEvent evt) { }    //   by the MouseListener
          public void mouseEntered(MouseEvent evt) { }    //   interface.
          public void mouseExited(MouseEvent evt) { }
        
       } // end class ColorChangeCanvas   
</pre>

<p>In this case, the same component that generates the mouse events is
listening for them.  This is not uncommon for mouse and keyboard events.</p>


<p>Often, when a mouse event occurs, you want to know the location of
the mouse cursor. This information is available from the parameter,
<tt>evt</tt>, of type <tt>MouseEvent</tt>.  To find the coordinates of
the mouse cursor, call <tt>evt.getX()</tt> and <tt>evt.getY()</tt>.  These
methods return integers which give the x and y coordinates in the component's
coordinate system, in which the top left corner is (0,0).</p>

<p>In some cases, you'd also like to know which button on the mouse was pressed.
The method <tt>evt.isMetaDown()</tt> returns a boolean value that is <tt>true</tt>
if the right button on the mouse is pressed.  Similarly, <tt>evt.isAltDown()</tt>
returns <tt>true</tt> if the middle button is down.  Now, not every mouse has
a middle button and a right button.  A user can simulate pressing the middle
mouse button by holding down the ALT key (on a Macintosh, the Option key)
while using the mouse.  This will work even on a computer that does
have a middle mouse button.  Similarly, holding down the Meta key (the
Command key on a Macintosh; no equivalent under Windows) simulates
pressing the right mouse button.  You can also tell whether the user
is holding down the shift key or the control key by calling
<tt>evt.isShiftDown()</tt> and <tt>evt.isControlDown()</tt>.</p>

<p>Here is a small sample applet that displays information about mouse
actions.  It is programed to respond to any of the seven diffent kinds of
mouse events by displaying the coordinates of the mouse, the type of event,
and a list of the modifier keys that are down (Shift, Control, Meta, and Alt).
Experiment to see what happens when you use the mouse on the applet. The source
code for this applet can be found in <a href="http://math.hws.edu/eck/cs124/javanotes2/source/SimpleTrackMouse.java">SimpleTrackMouse.java</a>.</p>

<center>
<applet code="CS124%20%20Java,%20Section%206.2_files/SimpleTrackMouse.class" height="200" width="350">
</applet>
</center>


<p>One of the operations that can be done with a mouse is <font color="#E70000">dragging</font>.
"Dragging" refers to moving the mouse while holding
down a mouse button.  If you want a component to respond to dragging,
you generally need to write three methods:  <tt>mousePressed()</tt>,
<tt>mouseDragged()</tt>, and <tt>mouseReleased()</tt>.  Your response
to one dragging gesture is spread out over three methods. Furthermore, the
<tt>mouseDragged()</tt> method can be called many times as the mouse moves.
You need to set up some instance variables to keep track of what is
going on between method calls.  Suppose, for example, that you
want to let the user sketch a curve by dragging the mouse.
Each time the mouse moves as it is being dragged, you have to
draw a line between the previous mouse location and the current 
mouse location.  To do this, you need to keep track of the
previous mouse location in a pair of instance variables. Here is
an outline of how you could write the program:</p>


<pre>        int prev_x;  // previous x coordinate of mouse
        int prev_y;  // previous y coordinate of mouse
        
        public void mousePressed(MouseEvent evt) {
           prev_x = evt.getX();  // record mouse location
           prev_y = evt.getY();
        }
        
        public void mouseDragged(MouseEvent evt) {
           int new_x = evt.getX();
           int new_y = evt.getY();
           ... // draw a line from (prev_x,prev_y) to (new_x,new_y)
           prev_x = new_x;
           prev_y = new_y;
        }
        
        public void mouseReleased(MouseEvent evt) {
           int new_x = evt.getX();
           int new_y = evt.getY();
           ... // draw a line from (prev_x,prev_y) to (new_x,new_y)
        }
</pre>

<p>Here's a trivial sketching program that uses this technique.  The applet
uses an off-screen image to store a copy of the sketch, so that it can
be redrawn when necessary (for example, if you cover up the applet with another window
and then uncover it).  Whenever a line needs to be drawn, it is drawn both
on the applet itself and on the backup copy in the off-screen image.  
As an added feature in this applet, you can clear the sketch
by right-clicking it (or by command-clicking on a Macintosh).  Try clicking
and dragging on the applet:</p>

<center>
<applet code="CS124%20%20Java,%20Section%206.2_files/TrivialSketch.class" height="200" width="300">
</applet>
</center>


<p>The source code for this simple sketching program is in the
file <a href="http://math.hws.edu/eck/cs124/javanotes2/source/TrivialSketch.java">TrivialSketch.java</a>.
The applet <tt>ShapeDraw</tt> from <a href="http://math.hws.edu/eck/cs124/javanotes2/c4/s3.html">Section 4.3</a>
uses dragging in a more substantial way.  The source code for
that applet is in the sample file <a href="http://math.hws.edu/eck/cs124/javanotes2/source/ShapeDraw.java">ShapeDraw.java</a>.


</p><hr align="center" width="33%">

<h3>Keyboard and Focus Events</h3>

<p>Events don't start out as Java objects.  Ultimately, events are caused by user
actions that are detected by the computer's operating system.  When the user moves
the mouse or presses a key, the system has to decide what to do with the information
about the user's action.  For a mouse action, the information usually goes to the visual GUI interface
element that contains the mouse cursor.  If that interface element happens to be a
Java component, then the information is converted into a Java <tt>MouseEvent</tt> object,
which is in turn sent through Java's event-handling process.  But what about keyboard
events?  When the user presses a key, where does that information go?</p>

<p>GUIs use the idea of <font color="#E70000">input focus</font> to determine where
information about keyboard events should be sent.  At a given time, exactly one interface
element on the screen has the input focus, and that is where all keyboard events are
sent.  If the interface element happens to be a Java component, then the information
about the keyboard event becomes a Java object of type <tt>KeyEvent</tt>.</p>

<p>It's a good idea to give the user some visual feedback about which component
has the input focus.  For example, if the component is the typing area of a
word-processor, the feedback is usually in the form of a blinking text cursor.
Another common visual clue is to draw a brightly colored border around the edge
of a component when it has the input focus, as I do in the sample applet later
on this page.</p>

<p>A component that wants to have the input focus can call the method <tt>requestFocus()</tt>,
which is defined in the <tt>Component</tt> class.  Calling this method does not absolutely
guarantee that the component will actually get the input focus.  Several components might
request the focus; only one will get it.  This method should only be used in
certain circumstances in any case, since it can be a rude surprise to the user to have
the focus suddenly pulled away from a component that the user is working with.
In general, the user can choose to give the focus to a component by clicking on
that component with the mouse.  And pressing the tab key will often move the focus
from one component to another.</p>

<p>Some components do not automatically receive the input focus when the user
clicks on them.  To solve this problem, a program has to register a mouse listener
with the component to detect user clicks.  In response to user clicks, the
<tt>mousePressed()</tt> method should call <tt>requestFocus()</tt> for the
component.  Unfortunately, which types of components require such treatment
varies from platform to platform.  In Sun Microsystem's implementation of
Java, for example, applet objects and canvas objects must be treated in
this way.  So if you create a subclass of <tt>Applet</tt> or <tt>Canvas</tt>
that is supposed to be able to respond to keyboard events, you should be sure
to set up a mouse listener for your class and call <tt>requestFocus()</tt>
in the <tt>mousePressed()</tt> method.  This is done in the sample applet
example given below.</p>

<p>If a component is to change its appearance when it has the input focus, it needs some
way to know when it has the focus.  In Java, objects are notified about changes of input
focus by events of type <tt>FocusEvent</tt>.  An object that wants to be notified of
changes in focus can implement the <tt>FocusListener</tt> interface.  This interface
declares two methods:</p>

<pre>         public void focusGained(FocusEvent evt);
         public void focusLost(FocusEvent evt);
</pre>

<p>Furthermore, the <tt>addFocusListener()</tt> method must be used to set
up a listener for the focus events.  When a component gets the input focus, it calls the
<tt>focusGained()</tt> method of any object that had been registered with that
component as a <tt>FocusListener</tt>.  When it loses the focus, it calls
the listener's <tt>focusLost()</tt> method.  Often, it is the component itself
that listens for focus events.</p>

<p>The following applet has a <tt>boolean</tt> instance variable, <tt>focussed</tt>,
which is set to true when the applet gains the focus and to false when it loses
the focus.  In the <tt>paint()</tt> method, when <tt>focussed</tt> is true,
a cyan-colored border is drawn around the applet.  When it is false, a message
is displayed advising the user to click on the applet to activate it.
When the applet has the input focus, you can use the arrow keys to move the
colored square up, down, left, and right.  You can also change the color
of the square to red, green, blue, or black by hitting the R, G, B, and K keys.
Try it:</p>


<center>
<applet code="CS124%20%20Java,%20Section%206.2_files/KeyboardAndFocusDemo.class" height="200" width="250">
</applet>
</center>


<p>In this example, the applet implements the <tt>FocusListener</tt> interface.
The <tt>init()</tt> method of the applet includes the command "addFocusListener(this);"
to arrange for the applet itself to be notified when it gains or loses focus.  The
<tt>focusGained()</tt> and <tt>focusLost()</tt> methods say simply</p>

<pre>         public void focusGained(FocusEvent evt) {
               // the applet now has the input focus
            focussed = true;
            repaint();  // redraw with cyan border
         }
   
         public void focusLost(FocusEvent evt) {
               // the applet has now lost the input focus
            focussed = false;
            repaint();  // redraw without cyan border
         }
</pre>

<p>This applet also handles events that are generated when the user manipulates the
keyboard.  These events belong to the class <tt>KeyEvent</tt>.  An object that wants
to be notified of <tt>KeyEvents</tt> must implement the <tt>KeyListener</tt> interface,
and it must be  registered with the component in which it is interested with that
component's <tt>addActionListener()</tt> method.  The <tt>KeyListener</tt> interface
defines three methods:</p>

<pre>          public void keyPressed(KeyEvent evt);
          public void keyReleased(KeyEvent evt);
          public void keyTyped(KeyEvent evt);
</pre>

<p>The <tt>keyTyped()</tt> method is called when an actual character has been typed.
The character can be determined by calling <tt>evt.getKeyChar()</tt>, which returns
a value of type <tt>char</tt>.  The other two methods, <tt>keyPressed()</tt>
and <tt>keyReleased()</tt> are called whenever a key is pressed or released,
including special keys like the shift key and arrow keys.  The key can be determined
by calling <tt>evt.getKeyCode()</tt>.  This method returns an <tt>int</tt> value,
which is a code for the key.  The possible values of this code are given by
constants in the <tt>KeyEvent</tt> class.  For example, the four
arrow keys correspond to the codes <tt>KeyEvent.VK_UP</tt>, <tt>KeyEvent.VK_DOWN</tt>,
<tt>KeyEvent.VK_LEFT</tt>, and <tt>KeyEvent.VK_RIGHT</tt>, and the code for
the shift key is <tt>KeyEvent.VK_SHIFT</tt>.  (The "VK" here stands for
"Virtual Keyboard.")</p>

<p>In the sample applet, I use the <tt>keyTyped()</tt> method to respond when the user
hits the R, G, B, or K key:</p>

<pre>         public void keyTyped(KeyEvent evt) {
          
            char ch = evt.getKeyChar();  // the character that was typed

            if (ch == 'B' || ch == 'b') {
               squareColor = Color.blue;
               repaint();
            }
            else if (ch == 'G' || ch == 'g') {
               squareColor = Color.green;
               repaint();
            }
            else if (ch == 'R' || ch == 'r') {
               squareColor = Color.red;
               repaint();
            }
            else if (ch == 'K' || ch == 'k') {
               squareColor = Color.black;
               repaint();
            }
   
         }  // end keyTyped()
         
</pre>

<p>and I use <tt>keyPressed()</tt> to respond when the user hits one of the
arrow keys:</p>

<pre>         public void keyPressed(KeyEvent evt) { 
                
            int key = evt.getKeyCode();  // keyboard code for the key that was pressed
            
            if (key == KeyEvent.VK_LEFT) {
               squareLeft -= 8;
               if (squareLeft &lt; 0)
                  squareLeft = 0;
               repaint();
            }
            else if (key == KeyEvent.VK_RIGHT) {
               squareLeft += 8;
               if (squareLeft &gt; width - 6 - squareSize)
                  squareLeft = width - 6 - squareSize;
               repaint();
            }
            else if (key == KeyEvent.VK_UP) {
               squareTop -= 8;
               if (squareTop &lt; 0)
                  squareTop = 0;
               repaint();
            }
            else if (key == KeyEvent.VK_DOWN) {
               squareTop += 8;
               if (squareTop &gt; height - 6 - squareSize)
                  squareTop = height - 6 -squareSize;
               repaint();
            }

         }  // end keyPressed()

</pre>

<p>Finally, the <tt>keyReleased()</tt> method, which is required to complete the
<tt>KeyListener</tt> interface, is defined to be empty:</p>

<pre>         public void keyReleased(KeyEvent evt) { 
            // empty method, required by the KeyListener Interface
         }
</pre>

<p>The complete source code for this applet is in the file
<a href="http://math.hws.edu/eck/cs124/javanotes2/source/KeyboardAndFocusDemo.java">KeyboardAndFocusDemo.java</a>.</p>

<hr>
</blockquote>

<p align="center"><font size="-1">
[ <a href="http://math.hws.edu/eck/cs124/javanotes2/c6/s3.html">Next Section</a>
| <a href="http://math.hws.edu/eck/cs124/javanotes2/c6/s1.html">Previous Section</a>
| <a href="http://math.hws.edu/eck/cs124/javanotes2/c6/index.html">Chapter Index</a>
| <a href="http://math.hws.edu/eck/cs124/javanotes2/index.html">Main Index</a>
]</font></p>




</body></html>